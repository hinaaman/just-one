"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRequestListener = void 0;
const node_stream_1 = require("node:stream");
const promises_1 = require("node:stream/promises");
require("./globals");
const getRequestListener = (fetchCallback) => {
    return async (incoming, outgoing) => {
        const method = incoming.method || 'GET';
        const url = `http://${incoming.headers.host}${incoming.url}`;
        const headerRecord = [];
        const len = incoming.rawHeaders.length;
        for (let i = 0; i < len; i += 2) {
            headerRecord.push([incoming.rawHeaders[i], incoming.rawHeaders[i + 1]]);
        }
        const init = {
            method: method,
            headers: headerRecord,
        };
        if (!(method === 'GET' || method === 'HEAD')) {
            // lazy-consume request body
            init.body = node_stream_1.Readable.toWeb(incoming);
            init.duplex = 'half';
        }
        let res;
        try {
            res = (await fetchCallback(new Request(url.toString(), init)));
        }
        catch (e) {
            res = new Response(null, { status: 500 });
            if (e instanceof Error) {
                // timeout error emits 504 timeout
                if (e.name === 'TimeoutError' || e.constructor.name === 'TimeoutError') {
                    res = new Response(null, { status: 504 });
                }
            }
        }
        const contentType = res.headers.get('content-type') || '';
        // nginx buffering variant
        const buffering = res.headers.get('x-accel-buffering') || '';
        const contentEncoding = res.headers.get('content-encoding');
        const contentLength = res.headers.get('content-length');
        const transferEncoding = res.headers.get('transfer-encoding');
        for (const [k, v] of res.headers) {
            if (k === 'set-cookie') {
                // node native Headers.prototype has getSetCookie method
                outgoing.setHeader(k, res.headers.getSetCookie(k));
            }
            else {
                outgoing.setHeader(k, v);
            }
        }
        outgoing.statusCode = res.status;
        if (res.body) {
            try {
                /**
                 * If content-encoding is set, we assume that the response should be not decoded.
                 * Else if transfer-encoding is set, we assume that the response should be streamed.
                 * Else if content-length is set, we assume that the response content has been taken care of.
                 * Else if x-accel-buffering is set to no, we assume that the response should be streamed.
                 * Else if content-type is not application/json nor text/* but can be text/event-stream,
                 * we assume that the response should be streamed.
                 */
                if (contentEncoding ||
                    transferEncoding ||
                    contentLength ||
                    /^no$/i.test(buffering) ||
                    !/^(application\/json\b|text\/(?!event-stream\b))/i.test(contentType)) {
                    await (0, promises_1.pipeline)(node_stream_1.Readable.fromWeb(res.body), outgoing);
                }
                else {
                    const text = await res.text();
                    outgoing.setHeader('Content-Length', Buffer.byteLength(text));
                    outgoing.end(text);
                }
            }
            catch (e) {
                // try to catch any error, to avoid crash
                console.error(e);
                const err = e instanceof Error ? e : new Error('unknown error', { cause: e });
                // destroy error must accept an instance of Error
                outgoing.destroy(err);
            }
        }
        else {
            outgoing.end();
        }
    };
};
exports.getRequestListener = getRequestListener;
